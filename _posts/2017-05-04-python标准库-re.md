---
published: true
layout: post
title: python标准库-re
category: python
tags: 
  - python
time: 2017.05.04 21:42:00
excerpt: 余弦:我没看过python的书，但我通读过python文档。文档不过一遍，视野会局限。近日读sqlmap源码，发现自己对于标准库所知甚少，想到knownsec技能表中余弦的一番话，加之最近有意提升English能力，遂意通读python2.7.13官方文档，去粗取精，译成中文，国内虽有一译站点已有翻译，但为参考。然本钱平平，词不达意，技止于此，望看客海涵。

---

余弦:我没看过python的书，但我通读过python文档。文档不过一遍，视野会局限。
近日读sqlmap源码，发现自己对于标准库所知甚少，想到knownsec技能表中余弦的一番话，加之最近有意提升English能力，遂意通读python2.7.13官方文档，去粗取精，译成中文，国内虽有一译站点已有翻译，但为参考。然本钱平平，词不达意，技止于此，望看客海涵。

<!--more-->

# Python标准库-re——正则表达式操作
本模块提供正则表达式匹配操作，这和Perl的正则很像。要匹配的模式和字符串既可以是Unicode串，也可以是8位字符串。

正则表达式使用反斜杠字符'\'来表示特殊的格式以消除特殊字符的效果，成为普通字符。这与字符串字面值中相同目的的同字符背道而驰；例如，匹配一个字面值的反斜杠，模式字符串必须写成`'\\\\'`，因为正则表达式必须是`\\`，每个反斜杠都要写成`'\\'`。

解决的方案是使用python的原始字符串来表示模式字符串；以'r'做为前缀的字符串不会对反斜杠进行转义。因此r'\n'是一个两个字符的字符串，包含'\'和'n'，同时"\n"是只包含一各字符——换行符的字符串。通常python代码中模式字符串使用原始字符串书写。

注意到大多数正则表达式操作可以利用模块级别的方法和RegexObject的方法。这些函数是快捷的形式，无需编译一个正则表达式对象，但会缺少一些调优的参数。

## 正则表达式语法
正则表达式（RE）制定了一个匹配的字符串集合；本模块的函数可以让你检查一个特定的字符串是否匹配给定的正则表达式（或给定的正则表达式是否匹配特定的字符串，这是一回事）。

正则表达式可以通过连结形成新的正则表达式。如果A和B是正则，那么AB也是正则。通常来说，如果字符串p匹配A，字符串q匹配B，那么pq就匹配AB。除非A或B包含低优先级的操作、A和B之间存在边界条件或存在编号组引用。因此，复杂的表达式可以轻易的由简单表达式组成。关于正则的理论和实现，可以咨询Friedl book，或者任意的有关编译器构造的教科书。

下面是对正则表达式的简单解释。更多信息和优雅的演示，请参考Regular Expression HOWTO。

正则表达式可以包含特殊和普通字符。大多数普通字符，如'A','a'或'0'，是最为简单的正则；它们仅仅匹配自己。你可以连接它们，因而last匹配字符串'last'。

一些字符，比如'|'或'('是特殊的。特殊字符	要么表示某个类别的普通字符，要么影响周围的正则如何解释。正则模式字符串不能包含空字节，但可以用\number的形式来指定空字节，例如'\x00'。

重复限定词(`*,+,?,{m,n}`等)不能直接嵌套。这避免了非贪婪修饰后缀?的二义性，以及一些其他实现中的修饰符。内部重复中想要应用第二个重复，需要用小括号。例如，表达式`(?:a{6})*`匹配任意个六连a字符。

特殊的字符：
- '.'
	- 点。默认模式，匹配除了换行符的任意字符。如果给定DOTALL标志，它匹配含换行符的任意字符。
- '^'
	- 匹配字符串的起始，在MULTILINE模式下也匹配每个行首。
- '$'
	- 匹配字符串末尾或换行符前的结尾，MULTIMODE模式也匹配换行符前的位置。`foo`匹配'foo'和'foobar'，然而`foo$`仅匹配'foo'。在'foo1\nfoo2\n'中搜索`foo.$`会匹配'foo2'，在MULTILINE模式下则匹配'foo1'；在'foo\n'中搜索单个`$`会找到两个匹配：一个是换行符前，一个是字符串末尾。
- '*'
	- 匹配前面重复出现的正则0到多次，尽可能多的匹配。`ab*`匹配'a','ab'或'a'后跟随任意数量的'b'。
- '+'
	- 匹配前面重复出现的正则1到多次。`ab+`匹配'a'跟随任意数目的'b'，不匹配'a'。
- '?'
	- 匹配前面出现的正则0到1次。`ab?`匹配'a'或'ab'。
- *?,+?,??
	- `'*','+','?'`限定符都是贪婪的，它们会尽可能的匹配。有些时候这是不可取的；当`<.*>`匹配`<a>b<c>`时，匹配的是整个串，而不是`<a>`。增加?限定符可以让它表现的非贪婪匹配，也就是最小化的适配；此时仅仅匹配`<a>`。
- {m}
	- 匹配当前RE重复的次数为m次，少于m的串不会匹配，比如`a{6}`严格匹配6个'a'，而不是5个。
- {m, n}
	- 匹配当前RE m到n次，尝试尽可能多的匹配。例如`a{3,5}`匹配3到5个'a'字符。m缺省为0，n缺省为无限大。例如，`a{4,}b`匹配'aaaab'或1000个'a'接一个'b',但'aaab'不行。逗号不可以省略。
- '\'
	- 对任意特殊字符转义，比如'*'和'?'，或表示一个特殊的序列，下面会描述特殊序列。
	- 如果你没有使用原始字符串来表示模式字符串，记住python也可以使用反斜杠来从字符串字面值转义序列，如果转义序列并不被python解释器认识，那么反斜杠和子序列字符被包含在结果字符串中。然而，如果python认出了结果序列，反斜杠应该被重复两次。理解起来较为复杂，因此使用原始字符串更为的简单。
- []
	- 用于指示一个字符集。在集合中：
		- 字符可以各自罗列，比如[amk]匹配'a'，'m'或'k'。
		- 给出两个字符并用'-'连接，比如[a-z]表示匹配任意小写字母，`[0-5][0-9]`匹配00到59的所有两位数，[0-9A-Fa-f]匹配十六进制数。如果'-'带有转义，或者出现在首尾处，则匹配'-'的字面值。
		- 特殊字符在集合中会丢失原本的特殊意义。例如`[(+*)]`匹配四个字符'(','+','*',')'。
		- 字符类比如`\w`或`\S`也被集合所接受，尽管它们匹配的字符取决于LOCALE或UNICODE模式是否是强制的。
		- 不在一段范围之内的字符可以通过补集匹配。如果集合的第一个字符是'^'，那么所有不在集合中的字符都被匹配。例如`[^5]`除了5之外都匹配，`[^^]`匹配除了'^'的所有字符。'^'如果不是集合的第一个字符，则没有特殊意义。
		- 匹配字面的']'，则需要用反斜杠转义，或者放在放在集合的前面。比如`[()[\]{}]`和`[]()[{}]`都匹配括号。
- '|'
	- `A|B`，A和B可以是任意的RE，这一RE意味着可以匹配A或B的一个。'|'可以分隔任意数量的正则。这也可以用于内部组。当目标字符串被扫描时，RE尝试用'|'从左到右分隔。当一个模式字符串完全匹配时，接受这个分支。这就意味着一旦A匹配了，B就不会再做尝试，尽管他可能会匹配的更长。换句话说，'|'操作符是非贪婪的。想要匹配一个字面值的'|'，需要用`\|`转义，或者用符号类闭合它，比如`[|]`。
- (...)
	- 匹配小括号中的正则表达式，指定了一组的起始与结尾；组的内容可以在匹配之后回溯出来，并且可以用于匹配在其后的含`\number`特殊序列的字符串中，下面会进行描述。想要匹配字面值'('或')'，需要用`\(`或`\)`转义，或者使用字符类闭合，如`[(] [)]`。
- (?...)
	- 扩展符号（'?'跟随'('不是有意义的其他值）。'?'后的第一个字符决定了这个结构的意义以及更多的语法。扩展通常不会创建一个新组；`(?P<name>...)`是个唯一的例外。下面是当前支持的扩展。
- (?iLmsux)
	- （一或多个字母，源于集合'i','L','m','s','u','x'。）该组匹配空串；字母设置相应的标志：re.I(忽略大小写)，re.L(依赖区域设置)，re.M(多行匹配)，re.S(点'.'匹配所有字符)，re.U(Unicode依赖)，re.X(verbose)，对于整个RE生效。（标记在Module Contents——模块内容一节有所描述。）如果你想包含一个标志作为正则的一部分，这是十分有用的，如此则不必给re.compile()函数传递一个flag参数。
	- 注意到(?x)标记会改变表达式如何被传递。他应该在表达式字符串的开始使用，或者在一到多个空白字符后使用。如果标记前没有空白字符，则结果是undefined。
- (?:...)
	- 非捕获版本的分组正则表达式。匹配括号里的内容，但是匹配到的内容不会作为一个分组，在匹配之后也就不能被回溯到。
- (?P<name>...)
	- 和`(...)`很像，但是通过分组匹配到的子串可以通过符号组名称name访问。组名字必须是有效的python标记符，每个组名称都必须被定义一旦使用了这样一个正则表达式。符号组也是数字顺序的组，就好比组没有被命名一样。
	- 命名组可以通过三个上下文引用。如果模式字符串是`(?P<quote>['"].*?(?P=quote))`(匹配用单引号或双引号括起来的字符串)。

| 组"quote"的上下文引用 | 引用方式 |
| -------------------- | ------ |
| 用模式字符串本身 | `(?P=quote)`或`\1` |
| 处理匹配对象m时 | `m.group('quote')`或`m.end('quote')`等等 |
| 作为字符串传递给re.sub()的参数repl时 | `\g<quote>` `\g<1>` `\1` |

- (?P=name)
	- 命名分组的反向引用；匹配前面匹配到的对应命名分组内容。
- (?#...)
	- 注释；内容仅仅被忽略。
- (?=...)
	- 匹配字符串如果`...`匹配了字符串的跟随串，但不保证是任何的串。这调用一个前向断言。例如，`Isaac (?=Asimov)`会匹配'Isaac'当且仅当它跟随'Asimov'。
- (?!...)
	- 如果`...`不匹配字符串的跟随串，则视为匹配。这是一个前向断言的反向结果。例如，`Isaac (?!Asimov)`当它不跟随'Asimov'时会匹配'Isaac'。
## 待续。。。