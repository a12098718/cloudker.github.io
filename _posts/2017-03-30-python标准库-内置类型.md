---
published: true
layout: post
title: python标准库-内置类型
category: python
tags: 
  - python
time: 2017.03.30 20:56:00
excerpt: 余弦:我没看过python的书，但我通读过python文档。文档不过一遍，视野会局限。近日读sqlmap源码，发现自己对于标准库所知甚少，想到knownsec技能表中余弦的一番话，加之最近有意提升English能力，遂意通读python2.7.13官方文档，去粗取精，译成中文，国内虽有一译站点已有翻译，但为参考。然本钱平平，词不达意，技止于此，望看客海涵。

---

余弦:我没看过python的书，但我通读过python文档。文档不过一遍，视野会局限。
近日读sqlmap源码，发现自己对于标准库所知甚少，想到knownsec技能表中余弦的一番话，加之最近有意提升English能力，遂意通读python2.7.13官方文档，去粗取精，译成中文，国内虽有一译站点已有翻译，但为参考。然本钱平平，词不达意，技止于此，望看客海涵。

<!--more-->

# Python标准库-内置类型
主要的内置类型有数字，序列，映射，文件，类，实例和异常。
某些对象类型支持一些操作；特别的，实际上所有对象都可以被比较，测试其真值与否，转换成string(用repr()或略有差异的str()函数，后者在print()函数写出该对象时被隐式调用)。

## 真值测试
任何对象都可以进行真值测试，使用if或while语句或下面的布尔操作符均可。下列的几种情况被认为是false：
- None
- False
- 数字类型的0，比如0,0L,0.0,0j
- 空的序列，比如'',(),[]。
- 空的映射，比如{}
- 用户定义类的实例，如果这个类定义了一个`__nonzero__()`或`__len__()`方法，且该方法返回的是0或布尔值False。

其他的所有值都被认为是true——因此大部分的对象一般都是true。
操作符和内置函数当需要返回一个布尔值时，往往返回0或者False来代表false，返回1或True来代表true，除非有其他规定（一个重要的差异：布尔操作符or和and总是返回操作数中的一个）。

## 布尔操作符——and,or,not
以下是bool操作符，按优先级升序排列：

| 操作符 | 结果 | 注意 |
| ----- | ----- | ---- |
| x or y | 如果x是false，则返回y，否则返回x | 短路操作符，当x为false时，才会执行y |
| x and y | 如果x是false，则返回x，否则返回y | 短路操作符，当x为true时，才会执行y |
| not x | 如果x是false，则返回True，否则返回False | not相比较其他非布尔操作符优先级较低，因此`not a==b`相当于not(a==b)，而`a==not b`是语法错误 |

## 比较
所有对象均支持比较操作符。它们拥有相同的优先级（高于布尔操作符）。比较可以写成链式；比如`x < y <= z`和`x<y and y<=z`等价（除了y只执行了一次外，且如果x<y是false的话，两个语句都不会执行z，即短路效应）。

| 操作符 | 意义 |
| ----- | ----- |
| < | 小于 |
| <= | 小于等于 |
| > | 大于 |
| >= | 大于等于 |
| == | 等于 |
| != | 不等于 |
| is | 对象一致 |
| is not | 对象不一致 |

注意：!=也可以写成<>，但这是为了向前兼容。新的代码应该使用!=。

不同类型对象，除了不同的数字类型和字符串类型，永远不要测试相等。这样的对象排序结果永远一致但顺序是随机的（使得异构数组的排序可以生成一致的结果）。此外，某些类型（比如file）只支持退化的比较概念，该类型的两个对象任意之间互不相等。同理，这些对象的排序是一致的但顺序随机。当任意一个操作数是复数时，<、>、=、>=运算符都会抛TypeError。

不同身份的类实例通常不等，除非该类定义了一个`__eq__()`方法或`__cmp__()`方法。

类实例通常不能与该类的其他实例或其他类型的对象进行排序，除非该类定义了足够的富比较方法(`__lt__()`,`__le__()`,`__gt__()`,`__ge__()`)或`__cmp__()`方法。

> C python实现细节：不同类型对象除了数字型，都是通过类型名字来排序。同类型的对象，如果本身不支持比较，则以地址排序。

两个具有等优先级的操作符，in和not in，仅序列类型支持。

## 数字类型——int, float, long, complex
有四种数字类型：int，long，float和complex。另外，布尔是int的子类型。python的int在C中用long实现，也就是说至少有32位的精度（`sys.maxint`被设为int的最大值，最小值是`-sys.maxint-1`）。long类型没有精度限制。float在C中则用double实现。精度信息以及浮点数在机器上的表示方法可以参考`sys.float_info`。complex拥有实部和虚部，都是一个float。可以通过`z.real`和`z.imag`来分别取到（标准库包含额外的数字类型，fractions用于保存分数，decimal用于控制用户定义精度的浮点数）。

数字可以由字面面值逐字创建，也可以由内建函数和操作符创建。未装饰的字面整型（包含二进制，十六进制和八进制数）如果大小没有超出int的表示范围，则会正确的创建出来（yield），如果超出了范围则yield一个long。''L或'l'做后缀的整型字面值yield一个long（推荐用‘L’因为'1l'和'11'长得太像了）。拥有小数点或指数符号的字面数值则yield一个float。自面值数型后跟一个'j'或'J'则yield一个虚数，用于得到一个复数。

python完全支持混合运算：当二进制运算操作符用在不同数字类型时，相对“狭义”的类型被转成另一个较“广义”的类型，关系为int < long < float < complex。多个混合数字型比较时采用同样的法则。转换类型时使用int()、long()、float()、complex()。

所有内置数字类型支持下列操作。

| 操作 | 结果 | 注意条目 |
| ----- | ---- | ------ |
| x + y | 求x和y的和 | / |
| x - y | 求x和y的差 | / |
| x * y | x和y的积 | / |
| x / y | x除以y | 1 |
| x // y | 地板除 | 4,5 |
| x % y | x模y | 4 |
| -x | x取负 | / |
| +x | x不做改变 | / |
| abs(x) | x绝对值 | 3 |
| int(x) | x转int | 2 |
| long(x) | x转long | 2 |
| float(x) | x转float | 6 |
| complex(re,im) | 实部为re，虚部为im的复数，im默认是0 | / |
| c.conjugate() | c的共轭 | / |
| divmod(x,y) | (x // y,x % y) | 3,4 |
| pow(x,y) | x的y次幂 | 3,7 |
| x**y | x的y次幂 | 7 |

注意：
1. 对整型除法来说，结果是整数。结果总是朝着小的方向取整：1/2是0，(-1)/2是-1，(-1)/(-2)是0。如果任意一个操作数是long，那么结果也是long，不论值的大小。
2. 用int()或long()转float时，会阶段小数点后的值，类似`math.trunc()`。使用math.floor()向下取整，`math.ceil()`向上取整。
3. 参考内置函数，有完整说明
4. 自2.3版本后不再推荐：地板除操作，模操作，divmod()函数都不再对复数可用。取而代之，如果合适的话，可用abs()转成float。
5. 同整型除法一致。
6. 浮点数也可以接受字符串"nan"和"inf"作为NaN和正负无穷，可以带可选的"+/-"号。
7. python定义`pow(0,0)`和`0**0`为1，和其他编程语言类似。

所有的`numbers.Real`类型（int，long和float）也包含下列操作：

| 操作 | 结果 |
| math.trunc(x) | x截断成整数 |
| round(x[, n]) | x对n位向下取整，如果n省略，默认为0 |
| math.floor(x) | 满足<=x的最大整数 |
| math.ceil(x) | 满足>=x的最小整数 | 

### 整型位操作
位操作仅对整型有效。负数被看做其补足值的两倍大小（假设有个足够大的数，操作中不会溢出）。
二进制位操作符的优先级均比数字操作符低，又都高于比较操作符。唯独`~`操作符具有和数字操作符相同的优先级（+和-）。
下表按升序排列位操作符。

| 操作符 | 结果 | 注意 |
| ----- | ---- | --- |
| `x 丨 y` | x，y按位或 | --- |
| `x ^ y` | x，y按位异或 | --- |
| `x & y` | 下，y按位与 | --- |
| `x << n` | x左移n位 | 1,2 |
| `x >> n` | x右移n位 | 1,3 |
| `~x` | x按位取反 | --- |

注意：
1. n为负数时是非法的，会抛ValueError
2. 左移n位等价于乘`pow(2, n)`。如果超出了int的大小，则返回long。
3. 右移操作符等价于除以`pow(2, n)`。

### 整型的额外方法
整型数实现了numbers.Integral抽象基类。此外，它们提供了一个额外的方法：
- int.bit_length()
- long.bit_length()
	- 返回用于表达该整型数所需要的位数，不包括符号和开头的0。

```python
>>> n = -37
>>> bin(n)
'-0b100101'
>>> n.bit_length()
6
```
- - 更为精确地，如果x非0，那么x.bit_length()是一个独特的整数k（`2**(k-1)<=abs(x)<2**k`）。同样的，如果`abs(x)`足够小到有一个可以向下取整的对数运算，那么`k=1 + int(log(abs(x), 2))`。如果x是0，则返回0。
  - 等价于：
 
```python
def bit_length(self):
	s = bin(self)
	s = s.lstrip('-0b')
	return len(s)
```  

### 浮点数的额外方法
float类型实现了numbers.Real抽象基类。float也具有以下的额外方法。
- float.as_integer_ratio()
	- 返回一对整数，这对整数构成的分数和float几近相等。对infinities和NaN抛OverflowError
- float.is_integer()
	- 如果float实例是一个有限的整数大小，则返回True，否则返回False。

```python
>>> (-2.0).is_integer()
True
>>> (3.2).is_integer()
False
```
有两个方法提供了十六进制字符串和float间的转换。尽管python的float以二进制数存储在内部，十进制串和float间的转换将引起一个向下取整的错误。相对而言，十六进制串允许精确的表示浮点数的规格。当调试时这两个方法很有用。
- float.hex()
	- 返回一个表示float数值的十六进制串。对有限的float来说，表达式串永远会以0x开头，以p和指数结尾。
- float.fromhex(s)
	- 类方法，返回一个由十六进制串s转成的float。s可以有首尾的空白字符。
	
**float.hex()是一个实例方法，而float.fromhex()是类方法。**

十六进制串以这种格式表示：
`[sign] ['0x'] integer ['.' fraction] ['p' exponent]`
sign是可选的+或-，integer和fraction是十六进制数字符串。exponent是十进制整数，可以有一个可选的符号前缀。integer和fraction中必须至少有一个十六进制数。

注意到指数是十进制写成而非十六进制，最终值为2的exponent次幂乘上系数。比如，十六进制串`0x3.a7p10`表示的是`(3 + 10./16 + 7./16**2) * 2.0 ** 10`或3740.0。

对3740.0做反向操作则会得到一个不同的十六进制串。

## 迭代类型
python的容器支持一个迭代的概念。这通过两种不同的方法实现。它们用来允许用户自己定义类来支持迭代。下面描述的序列详细内容，总是支持迭代方法。
对容器对象，为了支持迭代，需要定义个方法：
- `container.__iter__()`
	- 返回一个迭代对象。该对象需要支持下面描述的迭代协议。如果一个容器支持不同类型的迭代，那么可以提供额外的方法支持那些迭代器类型的明确的请求。（一个支持多种格式迭代器的对象例子，可以是一个树型结构，该结构支持深度和广度优先搜索。）该方法和在python/C API中对python对象的tp_iter类型结构位置一致。

迭代器对象本身需要支持下面的两个方法，都来自迭代器协议。
- `iterator.__iter__()`
	- 返回迭代器对象本身。这被用来允许容器和迭代器使用在for和in语句中。
- `iterator.next()`
	- 返回容器的下一个元素。如果没有更多地元素了，抛StopIteration。

python定义了多个迭代器对象去支持生成器和特定的容器类型，字典以及其他的特殊格式。特定的类型除了对迭代器协议的实现以外，并不重要。
协议的目的在于一旦迭代器的next()方法抛StopIteration，它可以继续处理后来的调用。没有遵循这一性质的实现被认为是破损的。

### 生成器类型
python的生产者提供一个方便的方式来支持迭代协议。如果一个容器对象的`__iter__()`方法作为一个生成器实现了，那么他可以自动的返回一个迭代器对象（技术上来说，是一个生成器对象）支持`__iter__()`和`next()`方法。

## 序列类型——str,unicode,list,tuple,bytearray,buffer,xrange
共有七个序列类型：字符串，unicode字符串，列表，元组，字节数组，缓冲区，xrange对象。

其他容器可参考内置dict和set类，以及collections模块。

string以单引号或双引号括起来，比如'xyzzy'，"frobozz"。Unicode字符串和字符串很相似，但是在语法上要特别的指定一个前导'u':u'abc'，u"def"。列表用中括号包裹，元素见用逗号隔开：[a, b, c]。元组成员以逗号分隔，可以有也可以没有小括号包括，但空的元组必须用括号包裹，比如`a, b, c`或`()`。单一元素的元组必须写成`(d,)`。

字节数组以内置的函数bytearray()创建。

缓冲区对象并不由python语法直接支持，但是可以利用内置函数buffer()创建。它们不支持连结和复制操作。

xrange对象和buffers类似，也没有直接语法来创建，但可以用xrange()函数来创建。它们不支持切片，连结和复制操作。对它们使用`in`,`not in`,`min()`,`max()`时无效的。

大部分序列类型支持下列操作。`in`和`not in`操作具有和比较操作同样的优先级。`+`和`*`操作具有和数字操作符相同的优先级。

下表列出的序列操作优先级以升序排列。s和t是某种序列类型，n，i和j是整型。

| 操作 | 结果 | 注意条目 |
| ---- | --- | ----- |
| x in s | 如果s中某个元素和x等同，返回True，否则返回False | 1 |
| x not in s | 如果s中某个元素和x等同，返回False，否则返回True | 1 |
| s + t | s和t的连接操作 | 6 |
| s * n, n * s | 等同于s自加n次 | 2 |
| s[i] | s的第i个元素，以0开始 | 3 |
| s[i:j] | 从i到j的切片 | 3,4 |
| s[i:j:k] | 从i到j的切片，步长为k | 3,5 |
| len(s) | s的长度 | -- |
| min(s) | s中最小的元素 | -- |
| max(s) | s中最大的元素 | -- |
| s.index(x) | s中第一个值为x的元素索引 | -- |
| s.count(x) | s中值为x的元素个数 | -- |
 
序列类型也支持比较操作。特别的，元组和列表按词典编纂序比较一致的元素。这意味着如果去比较相等，则每个元素都必须都有一个相等的元素，且这两个序列必须是同一个类型，同等长度。

注意：
- 1.当s是string或Unicode string对象时，在`in`和`not in`操作中表现的像一个子串测试。
- 2.n小于0时被当做0处理（此时yield一个和s同类型的空序列）。注意s中的元素不是复制的，它们被引用多次。常见于这样的编程写法：

```python
>>> lists = [[]] * 3
>>> lists
[[], [], []]
>>> lists[0].append(3)
>>> lists
[[3], [3], [3]]
```
`[[]]`是一个列表包含一个空列表成员，所以`[[]] * 3`产生的3个元素都指向同一个空列表，修改其中的一个，会印象其他所有的。建立不同列表的方法如下:

```python
>>> lists = [[] for i in range(3)]
>>> lists[0].append(3)
>>> lists[1].append(5)
>>> lists[2].append(7)
>>> lists
[[3], [5], [7]]
```
- 3.如果i或j是负数，索引从后向前取。但是注意-0依然是0。
- 4.从i到j的切片是前闭后开区间。如果i或j大于len(s)，使用len(s)。如果i被省略，默认为0。如果j被省略，默认为len(s)。如果j小于i，则返回空。
- 5.前闭后开区间，即`0<=n<(j-i)/k`。规则同4。
- 6.如果s和t都是string，python的实现比如CPython通常会进行一个格式`s=s+t`或`s+=t`分配的本地优化。可能的话，优化使得二次(O(n^2))时间复杂度的运行时间尽可能的小。优化取决于具体版本和所依赖的实现。对敏感代码的性能来说，更推荐用`str.join()`方法，对各种版本和实现来说，该方法确保始终在线性时间复杂度完成。

### 字符串方法
下面列出了八位字符串和Unicode对象支持的string方法。部分也对bytearray对象适用。

此外，python字符串支持序列类型的方法。输出格式化字符串可以使用模板字符串或%操作符。同样的，可以参考re模块中基于正则表达式的字符串函数。

- str.capitalize()
	- 返回一个字符串的拷贝，首字母大写，其余字母小写。
	- 对8位字符串来说，该方法依赖于区域设置。
- str.center(width[, fillchar])
	- 返回一个width长度的居中字符串str，fillchar用于padding，默认为空白。
- str.count(sub[, start[, end]])
	- 返回子串sub在str的start到end切片中出现的次数，子串之间不重叠。
- str.decode([encoding[, errors]])
	- 解码用encoding编码的字符串。encoding默认是默认字符串编码。errors用于指定一个错误控制的计划。默认是'strict'，意味着编码错误会抛UnicodeError。其他可能的值分别是'ignore','replace'以及通过codecs.register_error()注册的值。
- str.encode([encoding[, errors]])
	- 返回一个编码字符串。默认encoding是当前默认字符串编码。errors用于指定错误控制。默认值是'strict'，意味着编码错误会抛UnicodeError。其他可用的值分别是'ignore','replace','xmlcharrefreplace','backslashreplace'以及其他通过codecs.register_error()注册的值。
- str.endswith(suffix[, start[, end]])
	- 如果string以suffix结尾则返回True，否则返回False。suffix可以是一个元组，此时string从元组里找。如果有可选的start和end，则以这一切片做比较。
- str.expandtabs([tabsize])
	- 返回一个字符串的拷贝，其中所有的tab字符全被替换成一个或多个空格，这取决于当前的列和给定的tab尺寸。tab位置出现在每一个tab尺寸大小的字符处（默认是8，可能是在列0，8，16等等）。扩展字符串，会对当前列置0且逐字符检查。如果字符时tab，就会插入一个到多个字符到结果中直到当前列和下一个tab位置相等。（tab字符本身不拷贝。）如果字符是\n或\r，则拷贝并置当前列为0。其余字符正常拷贝，无论print时展示如何的格式，当前列都会递增。
- str.find(sub[, start[, end]])
	- 返回str中找到的子串sub出现的最小索引位，如果有start和end则作为切片。没找到则返回-1。
- str.format(*args, **kwargs)
	- 执行字符串格式化操作。调用此方法的字符串可以包含文本自面值或用{}替换的域。每个替换的域代表了其数字序索引的参数，或是一个关键字参数。返回一个字符串的拷贝，每个域被替换成和参数一致。详情可参考格式化字符串语法。

```python
>>> "The sum of 1 + 2 is {0}".format(1+2)
'The sum of 1 + 2 is 3'
```
- str.index(sub[, start[, end]])
	- 和find()类似，但在找不到时会抛ValueError。
- str.isalnum()
	- 如果所有字符都是字母或数字，则返回True，哪怕只有一个字符。否则返回False。
	- 对8位字符串来说，该方法依赖于区域设置
	- 。
- str.isalpha()
	- 如果所有字符都是字母，则返回True，哪怕只有一个字符，否则返回False。
	- 对8位字符串来说，该方法依赖于区域设置。
- str.isdigit()
	- 如果所有字符都是十进制数，则返回True，哪怕只有一个字符，否则返回False。
	- 对8位字符串来说，该方法依赖于区域设置。
- str.islower()
	- 如果所有区分大小写的字符都是小写的，则返回True，哪怕只有一个字符，否则返回False。
	- 对8位字符串来说，该方法依赖于区域设置。
- str.isspace()
	- 如果字符串中仅有空白字符，则返回True，哪怕只有一个字符，否则返回False。
	- 对8位字符串来说，该方法依赖于区域设置。
- str.istitle()
	- 如果是标题字符串则返回True，哪怕只有一个字符，例如大写字母后面必须跟小写字母或无大小写字符。否则返回False。
	- 对8位字符串来说，该方法依赖于区域设置。
- str.isupper()
	- 如果所有区分大小写的字符都是大写的，则返回True，哪怕只有一个字符，否则返回False。
	- 对8位字符串来说，该方法依赖于区域设置。
- str.join(iterable)
	- 用str来连接iterable的成员，返回一个字符串。
- str.ljust(width[, fillchar])
	- 返回一个左侧合理的长度为width的字符串。用fillchar作padding，默认为空格。如果width小于等于len(s)，则返回原始字符串。
- str.lower()
	- 返回一个字符串的拷贝，所有字符都被转为小写。
	- 对8位字符串来说，该方法依赖于区域设置。
- str.lstrip([chars])
	- 返回一个移除前导字符的字符串拷贝。chars是一个字符串，指明被移除的字符集合。如果被省略，或为None，则默认移除所有空白字符。chars并不是一个前缀字符串，而是一个所有值尽可能的组合。

```python
>>> '    spacious    '.lstrip()
'spacious    '
>>> 'www.example.com'.lstrip('cmowz.')
'example.com'
```
- str.partition(sep)
	- 在第一个sep出现的位置分割字符串，返回一个3元组包含了分割前部分，分割本身和分割后的部分。如果没有找到sep，则返回一个3元组包含字符串本身和两个空字符串。
- str.replace(old,new[,count])
	- 返回一个拷贝的字符串，其中所有的子串old被new替换。如果count给定，那么仅仅替换到count个old为止。
- str.rfind(sub[, start[, end]])
	- 反向搜索子串sub的位置，start:end为切片。如果找不到，返回-1。
- str.rjust(width[, fillchar])
	- 返回一个右侧合理的字符串，长度为width。fillchar用于padding（默认为空格）。如果width小于等于len(s)，则返回原始的string。
- str.rpartition(sep)
	- 在最后一个搜索到的sep处分割字符串，其他和partition一致。
- str.rsplit([sep[, maxsplit]])
	- 返回一个字符串列表，每个元素是string的一个单词，sep作为定界符。如果maxsplit给定了，则最多分maxsplit个词组，从右向左。如果sep没有给定或是None，则空白字符作为定界符。
- str.rstrip([chars])
	- 和lstrip类似，这个是从右向左。
- str.split([sep[, maxsplit]])
	- 和rsplit类似，这个从左向右。
- str.splitlines([keepends])
	- 返回一个字符串列表，按行分割。
	- python认为'\r'和'\n'以及"\r\n"为8位字符串的换行符。
```python
>>> 'ab c\n\nde fg\rkl\r\n'.splitlines()
['ab c', '', 'de fg','kl']
>>> 'ab c\n\nde fg\rkl\r\n'.splitlines(True)
['ab c\n', '\n', 'de fg\r', 'kl\r\n']
>>> "".splitlines()
[]
>>> "One line\n".splitlines()
['One line']
>>> ''.split('\n')
['']
>>> 'Two lines\n'.split('\n')
['Two lines', '']
```
- unicode.splitlines([keepends])
	- 返回一个字符串列表，每个成员为unicode的一行，和上面的类似。然而，unicode方法对换行的识别要广泛的多：
	
| Representation | Description |
| -------------- | ----------- |
| \n | 换行 |
| \r | 回车 |
| \r\n | 回车换行 |
| \v 或 \x0b | 行制表 |
| \r 或 \x0c | 表格换行 | 
| \x1c | 文件分隔符 |
| \x1d | 组分割符 |
| \x1e | 记录分隔符 |
| \x85 | 下一行 |
| \u2028 | 行分隔符 |
| \u2029 | 段落分隔符 |

- str.startswith(prefix[, start[, end]])
	- 如果string以prefix开头，返回True，否则返回False。prefix也可以是一个元组用来遍历。start和end作为可选的切片参数。
- str.strip([chars])
	- 返回一个字符串拷贝，去掉头尾的字符。如果chars给定，则去掉该集合中的字符，如果是缺省或为None，那么仅仅移除空白字符。chars不是前缀或后缀，而是一个集合的最大组合。
- str.swapcase()
	- 返回一个字符串的拷贝，大小写字母翻转。
	- 对8位字符串来说，该方法依赖于区域设置。
- str.title()
	- 返回一个首字母大写格式的字符串。
	- 该算法利用简单的独立于语法的定义，将连续的一组字母定义为一个单词。很多情况这可以正确的工作，但也意味着对缩略和构成词来说，结果不符合预期。
	- 可以用正则表达式来为“'”号构造一个更好的方法：

```python
import re
def titlecase(s):
	return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
					lambda mo: mo.group(0)[0].upper() +
								mo.group(0)[1:].lower(),
					s)
>>> titlecase("they're bill's friends.")
"They're Bill's Firends."
```
- str.translate(table[, deletechars])
	- 返回字符串的一个拷贝，删除所有deletechars中出现的字符。其余字符通过给定的table进行映射转换，转换表必须是长度位256的字符串。
	- 可以利用string模块的maketrans()场景一个转换表。对于字符串对象，如果转换只是删除字符，可以设置table为None。
	- 对Unicode对象，translate()不接受可选的deletechars参数。相反，它将返回一个字符串的拷贝，其中所有字符通过给定转换表映射，转换表此时必须为Unicode序到Unicode序的转换。未映射的字符原地不动，映射为None的字符被删除。使用codecs模块可以更为灵活的映射字符。
- str.upper()
	- 返回字符串的拷贝，所有区分大小写的字符转为大写。
	- 对8位字符串来说，此方法依赖于区域设置。
- str.zfill(width)
	- 返回数值字符串的左侧0到长度为width的子串。符号前缀会被正确的处理。如果width小于或等于len(s)，返回原始字符串。

下列方法只有Unicode对象具有：
- unicode.isnumeric()
	- 如果S中只有数值字符串，则返回True，否则返回False。数值字符串包括数字字符和具有数值属性的Unicode，例如U+2155表示分数五分之一。
- unicode.isdecimal()
	- 如果S中只有十进制字符，返回True，否则返回False。十进制字符包含数字字符和可构成十进制基数数字的字符。例如U+0660表示阿拉伯数字的0。

# 待续。。。